// Domain models - Playbook
// Journal entries, notes, and narrative generation for the relocation playbook

// ============================================================================
// EVENT TYPES
// ============================================================================

export type JournalEventType =
    | 'purchase'        // Item bought
    | 'task_complete'   // Task completed
    | 'expense'         // Expense added
    | 'packing'         // Box packed/unpacked
    | 'milestone'       // Key event (key handover, move day, etc.)
    | 'note';           // Manual note

export type JournalCategory =
    | 'acquisition'     // Shopping/buying
    | 'renovation'      // Paint, floors, repairs
    | 'admin'           // Contracts, utilities, paperwork
    | 'packing'         // Boxes, moving
    | 'custom';         // User-defined

export type RelatedEntityType =
    | 'shopping_item'
    | 'task'
    | 'expense'
    | 'box'
    | 'room';

export const JOURNAL_EVENT_LABELS: Record<JournalEventType, { label: string; emoji: string }> = {
    purchase: { label: 'Aankoop', emoji: 'üõí' },
    task_complete: { label: 'Taak voltooid', emoji: '‚úÖ' },
    expense: { label: 'Uitgave', emoji: 'üí∞' },
    packing: { label: 'Inpakken', emoji: 'üì¶' },
    milestone: { label: 'Mijlpaal', emoji: 'üéØ' },
    note: { label: 'Notitie', emoji: 'üìù' },
};

export const JOURNAL_CATEGORY_LABELS: Record<JournalCategory, { label: string; color: string }> = {
    acquisition: { label: 'Aankopen', color: '#3b82f6' },
    renovation: { label: 'Renovatie', color: '#f59e0b' },
    admin: { label: 'Administratie', color: '#8b5cf6' },
    packing: { label: 'Inpakken', color: '#22c55e' },
    custom: { label: 'Overig', color: '#6b7280' },
};

// ============================================================================
// JOURNAL ENTRY - Atomic log of an event
// ============================================================================

export interface JournalEntry {
    id: string;
    projectId: string;
    timestamp: Date;

    // Event classification
    eventType: JournalEventType;
    eventCategory: JournalCategory;

    // Context linking
    relatedEntityType?: RelatedEntityType;
    relatedEntityId?: string;
    roomId?: string;                // For room-based narrative grouping

    // Content
    title: string;                  // Auto-generated or custom
    description?: string;           // Details

    // Optional: Rich media
    photos?: string[];              // Base64 or blob URLs

    // Metadata for narrative generation
    monetaryValue?: number;         // In cents, for cost summaries
    isHighlight?: boolean;          // User-marked as important
    isAutoGenerated?: boolean;      // True if created by system
}

// ============================================================================
// PLAYBOOK NOTE - Manual user-written entry
// ============================================================================

export interface PlaybookNote {
    id: string;
    projectId: string;
    createdAt: Date;
    updatedAt: Date;

    title: string;
    content: string;                // Rich text / markdown
    tags: string[];
    roomId?: string;                // Optional room association
    isPinned: boolean;
}

// ============================================================================
// NARRATIVE REPORT - Generated summary
// ============================================================================

export interface RoomNarrative {
    roomId: string;
    roomName: string;
    roomEmoji: string;
    narrative: string;              // "In de woonkamer hebben we..."
    itemCount: number;
    totalSpent: number;
    highlights: JournalEntry[];
}

export interface NarrativeReport {
    summary: {
        totalSpent: number;
        itemsPurchased: number;
        tasksCompleted: number;
        boxesPacked: number;
        moveDate?: Date;
    };

    roomNarratives: RoomNarrative[];
    timeline: JournalEntry[];       // Chronological view
    tips: string[];                 // Auto-generated tips for next move
}

// ============================================================================
// HELPER FUNCTIONS
// ============================================================================

/**
 * Generate a title for a journal entry based on event type
 */
export function generateJournalTitle(
    eventType: JournalEventType,
    entityName?: string
): string {
    const labels = JOURNAL_EVENT_LABELS[eventType];
    if (entityName) {
        return `${labels.emoji} ${entityName}`;
    }
    return `${labels.emoji} ${labels.label}`;
}

/**
 * Group journal entries by date for timeline display
 */
export function groupEntriesByDate(entries: JournalEntry[]): Map<string, JournalEntry[]> {
    const groups = new Map<string, JournalEntry[]>();

    entries
        .sort((a, b) => new Date(b.timestamp).getTime() - new Date(a.timestamp).getTime())
        .forEach(entry => {
            const dateKey = new Date(entry.timestamp).toISOString().split('T')[0];
            const existing = groups.get(dateKey) || [];
            groups.set(dateKey, [...existing, entry]);
        });

    return groups;
}

/**
 * Format date for display in Dutch
 */
export function formatJournalDate(date: Date): string {
    return new Intl.DateTimeFormat('nl-NL', {
        weekday: 'long',
        day: 'numeric',
        month: 'long',
        year: 'numeric',
    }).format(new Date(date));
}

/**
 * Get relative time string (e.g., "2 uur geleden")
 */
export function getRelativeTime(date: Date): string {
    const now = new Date();
    const diffMs = now.getTime() - new Date(date).getTime();
    const diffMins = Math.floor(diffMs / 60000);
    const diffHours = Math.floor(diffMins / 60);
    const diffDays = Math.floor(diffHours / 24);

    if (diffMins < 1) return 'zojuist';
    if (diffMins < 60) return `${diffMins} min geleden`;
    if (diffHours < 24) return `${diffHours} uur geleden`;
    if (diffDays === 1) return 'gisteren';
    if (diffDays < 7) return `${diffDays} dagen geleden`;
    return formatJournalDate(date);
}

/**
 * Calculate stats from journal entries
 */
export function calculateJournalStats(entries: JournalEntry[]): {
    totalEntries: number;
    purchases: number;
    tasksCompleted: number;
    totalSpent: number;
    highlights: number;
} {
    return entries.reduce(
        (acc, entry) => {
            acc.totalEntries++;
            if (entry.eventType === 'purchase') acc.purchases++;
            if (entry.eventType === 'task_complete') acc.tasksCompleted++;
            if (entry.monetaryValue) acc.totalSpent += entry.monetaryValue;
            if (entry.isHighlight) acc.highlights++;
            return acc;
        },
        { totalEntries: 0, purchases: 0, tasksCompleted: 0, totalSpent: 0, highlights: 0 }
    );
}
